#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Метод поиска в пространстве состояний (или пространственного поиска) включает в себя построение графа состояний, где каждый узел представляет конкретное состояние, и поиск пути от начального состояния к целевому состоянию. Этот метод широко применяется для решения следующих задач:

1. Логический вывод: Метод поиска в пространстве состояний особенно полезен при логическом выводе, где необходимо найти все возможные последовательности логических операций или условий, которые приводят к заданному результату.
2. Планирование и планирование действий: Метод поиска в пространстве состояний может использоваться для генерации оптимального плана действий, учитывая ограничения и цели предметной области.
3. Решение задач поиска: Метод поиска в пространстве состояний используется для решения задач, таких как задача коммивояжера, задача о рюкзаке и другие, где необходимо найти оптимальный путь или комбинацию решений.

Prolog является удобным языком для решения таких задач по нескольким причинам:
1. Логическое программирование: Prolog основан на логическом программировании, что делает его естественным выбором для решения логических задач и задач поиска.
2. Логический вывод: Пролог обладает мощным механизмом логического вывода, который позволяет использовать интуицию и логическое мышление для определения правил и фактов, а затем автоматически находить решения на основе этих правил.
3. Шаблонное сопоставление: Пролог поддерживает шаблонное сопоставление, которое является мощным инструментом для поиска с привязкой переменных, что особенно полезно при решении задач поиска в пространстве состояний.
4. Эффективный поиск: Пролог предоставляет механизмы для эффективного поиска, такие как обрезка отсечений (cut), которая может ускорить поиск и исключить ненужные варианты.

Все эти особенности делают Prolog удобным языком для решения задач поиска в пространстве состояний.

## Задание

Железнодорожный сортировочный узел устроен так, как показано на рисунке. На левой стороне собрано некоторое число вагонов двух типов(черные и белые), обоих типов по n штук, в произвольном порядке. Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными операциями (слева в тупик, из тупика направо, слева направо, минуя тупик), собрать вагоны на правой стороне, так, чтобы типы чередовались. Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

Для решения этой задачи были использованы поиск в глубину, ширину и с итерационным погружением. 
Поиск в глубину представляет собой алгоритм, который продлевает пути до тех пор, пока не получит необходимое состояние. Если из какого-то состояния пути нет, происходит откат.

```prolog
% Поиск в глубину
dfs_path([X|T],X,[X|T]).
dfs_path(P,Y,R):- prolong(P,P1), dfs_path(P1,Y,R).
dfs(X,Y,P):- dfs_path([X],Y,P).
```
Поиск в ширину ищет самое короткое решение, он сначала проверяет, нет ли искомого состояния, а потом уже продлевает пути, пока не найдет нужное состояние.
```prolog
bfs_path([[X|T]|_],X,[X|T]). 
bfs_path([P|QI],X,R) :- findall(Z,prolong(P,Z),T),append(QI,T,QO),!,bfs_path(QO,X,R).
bfs_path([_|T],Y,L) :- bfs_path(T,Y,L).
bfs(X,Y,P) :- bfs_path([[X]],Y,P).
```
Поиск с итерационным заглублением - тот же поиск в глубину только отличяется тем, что решением считаются исключительно те пути, длина которых меньше заданного числа. В данной задаче количество передвижений поездов должно быть ограничено 3 * N - 1, где N - количество поездов одного цвета.
```prolog
id_path([X | T], X, [X | T], _).
id_path(P, B, R, N):- N > 0, prolong(P, P1), N1 is N - 1, id_path(P1, B, R, N1).
id(s(X, Y, Z), B, R) :- length(X,L), N is 3 * L / 2, id_path([s(X, Y, Z)], B, R, N).
```
Остается задать только перебор и вывод.
Перебор осуществляется простым ветвление всех возможных вариантов.
```prolog
prolong([X|T], [Y,X|T]) :- move(X,Y),not(member(Y,[X|T])).
move(s([A|AT],B,C), s(AT,B,[A|C])) :- first(C,X), X\=A.
move(s(A,[B|BT],C), s(A,BT,[B|C])) :- first(C,X), X\=B.
move(s([A|AT],B,C), s(AT,[A|B],C)) :- first(C,X), X==A.
```

Вывод более сложный, так как именно в нем осуществляется проверка условий задачи.
```prolog
solve(X,R):- 
    reverse(X,X1), 
    permutation(X1,Y), 
    bw(Y),
    get_time(Start), 
    bfs(s(X1,[],[]),     % здесь bfs, dfs или id - в зависимости от вида поиска
    s([],[],Y),W), 
    get_time(End), 
    T is End - Start,
    write('run time:'), write(T), write('\n'),
    reverse_lists(W,W1), 
    reverse(W1,R), !.
```

## Результаты
Поиск в глубину.
```prolog
solve([white,white,white,black,black,black],X).
run time:6.19888305663e-6
X = [s([white, white, white, black, black, black], [], []), s([white, white, white, black, black], 
[], [black]), s([white, white, white, black], [black], [black]), s([white, white, white], [black, black], 
[black]), s([white, white], [black, black], [black, white]), s([white, white], [black], [black, white, 
black]), s([white], [black], [black, white, black, white]), s([white], [], [black, white, black, white, 
black]), s([], [], [black, white, black, white, black, white])]
```
Поиск в ширину.
```prolog
solve([white,black,white,black,white,black],X).
run time:2.38428836595e-5
X = [s([white, black, white, black, white, black], [], []), s([white, black, white, black, white], 
[], [black]), s([white, black, white, black], [], [black, white]), s([white, black, white], [], 
[black, white, black]), s([white, black], [], [black, white, black, white]), s([white], [], [black, 
white, black, white, black]), s([], [], [black, white, black, white, black, white])]
```
Поиск с итеративным погружением.
```prolog
solve([white,black,white,black,white,black],X).
run time:5.72204589845e-6
X = [s([white, black, white, black, white, black], [], []), s([white, black, white, black, white], 
[], [black]), s([white, black, white, black], [], [black, white]), s([white, black, white], [], 
[black, white, black]), s([white, black], [], [black, white, black, white]), s([white], [], [black, 
white, black, white, black]), s([], [], [black, white, black, white, black, white])]
```

! Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-------------------------------------------------------------------|
| В глубину       |               9                |6.19888305663e-6|
| В ширину        |               9                |2.38428836595e-5|
| ID              |               9                |5.72204589845e-6|

## Выводы

В ходе выполнения лабораторной работы, я ознакомился с применением метода поиска в пространстве состояний и изучил его применимость в различных задачах. Мне удалось понять, что метод поиска в пространстве состояний эффективно применяется в задачах логического вывода, планирования и решения задач поиска.

Определенно, эта работа заставила меня задуматься о различных алгоритмах поиска в пространстве состояний и их оптимальности в различных ситуациях. При решении конкретной задачи поиска в пространстве состояний, необходимо учитывать особенности задачи, такие как структура данных и ограничения. Во время выполнения лабораторной работы, я столкнулся с такими алгоритмами как поиск в глубину и поиск в ширину, которые обеспечивают полный перебор состояний, но эффективность их работы может зависеть от размера пространства состояний.

В моем конкретном случае задачи поиска с использованием метода поиска в пространстве состояний, алгоритм поиска в ширину оказался более оптимальным. Этот алгоритм позволил мне решить задачу эффективно и получить правильные результаты, учитывая структуру данных и условия задачи.


